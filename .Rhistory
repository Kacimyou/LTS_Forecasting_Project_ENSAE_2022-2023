acf(y_diff)
pacf(y_diff)
source("~/GitHub/LTS_Forecasting_Project_ENSAE_2022-2023/main.R", echo=TRUE)
acf(y_diff)
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2005+1/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
y_second_diff = zoo(y_second_diff)
plot.zoo(dates, y)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y_second_diff)
acf(y_num)
summary(lm( formula = y ~ dates))
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc")
adf
summary(lm( formula = y_second_diff ~ dates[-c(1,2)]))
adf <- adfTest_valid(y_second_diff,24, type="nc")
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
datafile <- "valeurs_mensuelles.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2005+1/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
dates <- as.yearmon(seq(from=2010+1/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
y_second_diff = zoo(y_second_diff)
plot.zoo(dates, y)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y_second_diff)
acf(y_num)
summary(lm( formula = y ~ dates))
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc")
adf
summary(lm( formula = y_second_diff ~ dates[-c(1,2)]))
adf <- adfTest_valid(y_second_diff,24, type="nc")
datafile <- "valeurs_mensuelles.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2010+1/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
dates <- as.yearmon(seq(from=2007+1/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
y_second_diff = zoo(y_second_diff)
plot.zoo(dates, y)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y_second_diff)
acf(y_num)
summary(lm( formula = y ~ dates))
summary(lm( formula = y_diff ~ dates[-1]))
summary(lm( formula = y ~ dates))
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc")
adf
### Identification of p and q ###
par(mfrow=c(1,1)) #puts the graphs into 1 column and 2 lines
acf(y_diff)
pacf(y_diff)
plot(y, ylim =c(60,160))
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2007+1/12, to=2023+3/12, by=1/12))
dates <- as.yearmon(seq(from=2007+1/12, to=2020+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
y_second_diff = zoo(y_second_diff)
plot.zoo(dates, y)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y, ylim =c(60,160))
require(forecast)
require(zoo)
require(tseries)
require(fUnitRoots)
########################################
### Import the data and set the path ###
########################################
path <- "C:\\Users\\youns\\Documents\\GitHub\\LTS_Forecasting_Project_ENSAE_2022-2023"
setwd(path) #definit l'espace de travail (working directory ou "wd")
getwd() #affiche le wd
list.files() #liste les elements du wd
datafile <- "valeurs_mensuelles.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2007+1/12, to=2020+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
y_second_diff = zoo(y_second_diff)
plot.zoo(dates, y)
plot(y, ylim =c(60,160))
########################################
### Import the data and set the path ###
########################################
path <- "C:\\Users\\youns\\Documents\\GitHub\\LTS_Forecasting_Project_ENSAE_2022-2023"
setwd(path) #definit l'espace de travail (working directory ou "wd")
getwd() #affiche le wd
list.files() #liste les elements du wd
datafile <- "valeurs_mensuelles.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2007+1/12, to=2020+3/12, by=1/12))
dates <- as.yearmon(seq(from=2010+1/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
y_second_diff = zoo(y_second_diff)
plot.zoo(dates, y)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y_second_diff)
acf(y_num)
summary(lm( formula = y ~ dates))
summary(lm( formula = y_diff ~ dates[-1]))
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc")
adf
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2010+1/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2005+1/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
y_second_diff = zoo(y_second_diff)
plot.zoo(dates, y)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y_second_diff)
acf(y_num)
summary(lm( formula = y ~ dates))
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc")
adf
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc")
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc")
require(zoo)
require(tseries)
require(fUnitRoots)
########################################
### Import the data and set the path ###
########################################
path <- "C:\\Users\\youns\\Documents\\GitHub\\LTS_Forecasting_Project_ENSAE_2022-2023"
setwd(path) #definit l'espace de travail (working directory ou "wd")
getwd() #affiche le wd
list.files() #liste les elements du wd
datafile <- "valeurs_mensuelles.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2008+10/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
y_second_diff = zoo(y_second_diff)
plot.zoo(dates, y)
plot(y, ylim =c(60,160))
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y_second_diff)
acf(y_num)
summary(lm( formula = y ~ dates))
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc")
adf <- adfTest_valid(y_diff,24, type="ct")
adf <- adfTest_valid(y_diff,24, type="nc")
adf
y_second_diff = diff(y, differences = 2)#second difference
y_second_diff = diff(y, differences = 1, lag = 1)#second difference
2
y_second_diff = diff(y, differences = 2)#second difference
acf(y_diff)
pacf(y_diff)
arima(y_wo_trend,c(2,0,2)) # p= 2 q= 2
arima202 <- arima(y_wo_trend,c(2,0,2))
### Ljung Box test to check if residuals are not correlated ####
Box.test(arima202$residuals, lag=5, type="Ljung-Box", fitdf=4) #
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2008+10/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y_second_diff)
acf(y_num)
summary(lm( formula = y ~ dates))
arima(y_wo_trend,c(2,0,2)) # p= 2 q= 2
arima202 <- arima(y_wo_trend,c(2,0,2))
### Ljung Box test to check if residuals are not correlated ####
Box.test(arima202$residuals, lag=5, type="Ljung-Box", fitdf=4) #
arima202 <- arima(y_wo_trend,c(2,0,2))
arima202 <- arima(y_diff,c(2,0,2))
### Ljung Box test to check if residuals are not correlated ####
Box.test(arima202$residuals, lag=5, type="Ljung-Box", fitdf=4) #
datafile <- "valeurs_mensuelles.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2008+10/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
require(forecast)
require(zoo)
require(tseries)
require(fUnitRoots)
########################################
### Import the data and set the path ###
########################################
path <- "C:\\Users\\youns\\Documents\\GitHub\\LTS_Forecasting_Project_ENSAE_2022-2023"
setwd(path) #definit l'espace de travail (working directory ou "wd")
getwd() #affiche le wd
list.files() #liste les elements du wd
datafile <- "valeurs_mensuelles.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2008+10/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
y_second_diff = diff(y_diff, differences = 1)#second difference
y_second_diff = zoo(y_second_diff)
plot.zoo(dates, y)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y_second_diff)
acf(y_num)
summary(lm( formula = y ~ dates))
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc")
adf
summary(lm( formula = y_second_diff ~ dates[-c(1,2)]))
require(forecast)
require(zoo)
require(tseries)
require(fUnitRoots)
########################################
### Import the data and set the path ###
########################################
path <- "C:\\Users\\youns\\Documents\\GitHub\\LTS_Forecasting_Project_ENSAE_2022-2023"
########################################
### Import the data and set the path ###
########################################
path <- "C:\\Users\\youns\\Documents\\GitHub\\LTS_Forecasting_Project_ENSAE_2022-2023"
setwd(path) #definit l'espace de travail (working directory ou "wd")
getwd() #affiche le wd
list.files() #liste les elements du wd
datafile <- "valeurs_mensuelles.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2008+10/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
plot(y, ylim =c(60,160))
plot(y_diff)
plot(y, ylim =c(60,160))
# Let’s regress y on its dates to check :
summary(lm( formula = y ~ dates))
adf <- adfTest_valid(y,24, type="ct") # ct here take into account the fact that y has an intercept and non zero trend.
adf
plot(y, ylim =c(60,160))
plot(y_diff)
# Let’s regress y on its dates to check :
summary(lm( formula = y ~ dates))
# Let’s regress y on its dates to check :
summary(lm( formula = y ~ dates))
adf <- adfTest_valid(y,24, type="ct") # ct here take into account the fact that y has an intercept and non zero trend.
adf <- adfTest_valid(y,24, type="ct") # ct here take into account the fact that y has an intercept and non zero trend.
y_num = as.numeric(y)
adf <- adfTest_valid(y_num,24, type="ct") # ct here take into account the fact that y has an intercept and non zero trend.
adf
#The coefficient associated with the linear trend (dates) is indeed negative, thus we
#need to study the case of unit root tests with intercept and possibly non zero trends.
adf <- adfTest(spread, lag=0, type="ct")
#The coefficient associated with the linear trend (dates) is indeed negative, thus we
#need to study the case of unit root tests with intercept and possibly non zero trends.
adf <- adfTest(y_num, lag=0, type="ct")
adf
#Before interpreting the test, let’s check that the model’s residuals are not autocorrelated, otherwise the test
#would not be valid.
Qtests(adf@test$lm$residuals24,length(adf@test$lm$coefficients))
#Before interpreting the test, let’s check that the model’s residuals are not autocorrelated, otherwise the test
#would not be valid.
Qtests(adf@test$lm$residuals,24,length(adf@test$lm$coefficients))
adf <- adfTest_valid(y_num,24, type="ct") # ct here take into account the fact that y has an intercept and non zero trend.
#We have had to consider 21 lags on the ADF test to erase residual autocorrelation.
adf
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc") # nc here take into account the fact that y has no intercept and zero trend.
adf
### Identification of p and q ###
par(mfrow=c(1,1)) #puts the graphs into 1 column and 2 lines
acf(y_diff)
pacf(y_diff)
require(forecast)
require(zoo)
require(tseries)
require(fUnitRoots)
########################################
### Import the data and set the path ###
########################################
path <- "C:\\Users\\youns\\Documents\\GitHub\\LTS_Forecasting_Project_ENSAE_2022-2023"
setwd(path) #definit l'espace de travail (working directory ou "wd")
getwd() #affiche le wd
list.files() #liste les elements du wd
datafile <- "valeurs_mensuelles.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
dates_char <- as.character(data[[1]])
T <- length(dates_char)
dates_char <- dates_char[4:T]
dates_char[1]
tail(dates_char,1)
dates <- as.yearmon(seq(from=2008+10/12, to=2023+3/12, by=1/12))
y <-zoo(data[[2]][4:T], order.by=dates)
y_num = as.numeric(y)
y_diff = diff(y_num, differences = 1)#first difference
y_diff = zoo(y_diff)
plot(y, ylim =c(60,160))
plot(y_diff)
# Let’s regress y on its dates to check :
summary(lm( formula = y ~ dates))
adf <- adfTest(y_num, lag=0, type="ct") # ct here take into account the fact that y has an intercept and non zero trend.
adf <- adfTest(y_num, lag=0, type="ct") # ct here take into account the fact that y has an intercept and non zero trend.
Qtests(adf@test$lm$residuals,24,length(adf@test$lm$coefficients))
adf <- adfTest_valid(y_num,24, type="ct") # ct here take into account the fact that y has an intercept and non zero trend.
adf
adf <- adfTest_valid(y_num,24, type="ct") # ct here take into account the fact that y has an intercept and non zero trend.
adf
summary(lm( formula = y_diff ~ dates[-1]))
adf <- adfTest_valid(y_diff,24, type="nc") # nc here take into account the fact that y has no intercept and zero trend.
#It was necessary to include 1 lags in the ADF test
adf
plot(y_diff)
### Useful function ###
adfTest_valid <-
function(series,kmax,type){ #ADF tests until no more autocorrelated residuals
k <- 0
noautocorr <- 0
while (noautocorr==0){
cat(paste0("ADF with ",k, " lags: residuals OK? "))
adf <- adfTest(series,lags=k,type=type)
pvals <- Qtests(adf@test$lm$residuals,24,fitdf=length(adf@test$lm$coefficients))[,2]
if (sum(pvals<0.05,na.rm=T) == 0) {
noautocorr <- 1; cat("OK \n")}
else cat("nope \n")
k <- k + 1
}
return(adf)
}
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
### Identification of p and q ###
par(mfrow=c(1,2)) #puts the graphs into 1 column and 2 lines
acf(y_diff)
pacf(y_diff)
signif <- function(estim){
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
arimafit <- function(estim){
adjust <- round(signif(estim),3)
pvals <- Qtests(estim$residuals,24,length(estim$coef)-1)
pvals <- matrix(apply(matrix(1:24,nrow=6),2,function(c) round(pvals[c,],3)),nrow=6)
colnames(pvals) <- rep(c("lag", "pval"),4)
cat("Nullity test of the coefficients :\n")
print(adjust)
cat("\n Test of absence of residuals autocorrelation : \n")
print(pvals)
}
estim <- arima(y_wo_trend,c(1,0,0)); arimafit(estim) # Nope:The model is not valid
estim <- arima(y_wo_trend,c(2,0,0)); arimafit(estim) # OK:The model is well adjusted and valid
ar2 <- estim
estim <- arima(y_wo_trend,c(0,0,1)); arimafit(estim) # Nope:The model is not valid
estim <- arima(y_wo_trend,c(0,0,2)); arimafit(estim) # OK:The model is well adjusted and valid
ma2 <- estim
estim <- arima(y_wo_trend,c(1,0,1)); arimafit(estim) # OK:The model is well adjusted and valid
ar1ma1 <- estim
estim <- arima(y_wo_trend,c(1,0,2)); arimafit(estim) # Nope:The model is not properly adjusted
estim <- arima(y_wo_trend,c(2,0,1)); arimafit(estim) # Nope:The model is not properly adjusted
estim <- arima(y_wo_trend,c(2,0,2)); arimafit(estim) # OK:The model is well adjusted and valid
ar2ma2 <- estim
### Compute the AIC BIC matrix of valid models #####
models <- c("ar2","ma2",'ar1ma1',"ar2ma2"); names(models) <- models
apply(as.matrix(models),1, function(m) c("AIC"=AIC(get(m)), "BIC"=BIC(get(m))))
models <-  c("ar2","ma2",'ar1ma1',"ar2ma2")
preds <- zoo(matrix(NA,ncol=4,nrow=4),order.by=tail(index(y.source),4))
colnames(preds) <- models
y_diff_pred <- preds #
y_pred <- preds #
for (m in models){
pred1 <- mean(y_diff) + zoo(predict(get(m),4)$pred, order.by=tail(index(y.source),4))
pred2 <- as.numeric(tail(y,12))[1:4] + pred1
y_diff_pred[,m] <- pred1
y_pred[,m] <- pred2
}
obs <- tail(y.source,4) #
cbind(obs,y_pred) #
models <-  c("ar2","ma2",'ar1ma1',"ar2ma2")
preds <- zoo(matrix(NA,ncol=4,nrow=4),order.by=tail(index(y.source),4))
colnames(preds) <- models
y_diff_pred <- preds #
y_pred <- preds #
for (m in models){
pred1 <- mean(y_diff) + zoo(predict(get(m),4)$pred, order.by=tail(index(y.source),4))
pred2 <- as.numeric(tail(y,12))[1:4] + pred1
y_diff_pred[,m] <- pred1
y_pred[,m] <- pred2
}
obs <- tail(y.source,4) #
cbind(obs,y_pred) #
